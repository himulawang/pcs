var Model = function Model() {};

/* retrieve stuff start */
Model.prototype.retrieve = function(key, cb) {
    cb = cb || function() {};
    switch (this.type) {
        case I.Const.OBJECT_TYPE_HASH:
            this.retrieveHash(key, cb);
            break;
        case I.Const.OBJECT_TYPE_LIST:
            this.retrieveList(key, cb);
            break;
        default:
            throw new I.Exception(10101);
    }
};

Model.prototype.retrieveHash = function(key, cb) {
    var self = this;
    var dbMulti = db.multi();
    dbMulti.hkeys(this.abb + key);
    dbMulti.hvals(this.abb + key);
    dbMulti.exec(function(err, results) {
        if (err) return cb(new I.Exception(10103, err));

        var keys = results[0];
        var data = results[1];

        // convert '1' to 1
        var array = [];
        var util = I.Util;
        for (var i = 0; i < data.length; ++i) {
            array[keys[i]] = util.isUInt(data[i]) ? parseInt(data[i]) : data[i];
        }

        var object = new global[self.objectName](array);
        cb(null, object);
    });
};

Model.prototype.retrieveList = function(key, cb) {
    var self = this;
    db.hkeys(this.abb + key, function(err, data) {
        if (err) return cb(new I.Exception(10107, err));
        // empty list
        if (data.length === 0) {
            var list = new global[self.objectName](key);
            cb(null, list);
            return;
        }

        var objectList = {};
        var retrievedCount = 0;
        // fill elements
        data.forEach(function(v) {
            global[self.childModel].retrieve(v, function(err, object) {
                objectList[v] = object;
                ++retrievedCount;
                if (data.length === retrievedCount) {
                    var list = new global[self.objectName](key, objectList);
                    cb(null, list);
                }
            });
        });
    });
};
/* retrieve stuff end */

/* add stuff start */
Model.prototype.add = function(object, cb) {
    cb = cb || function() {};
    if (this.type === I.Const.OBJECT_TYPE_LIST) return cb(new I.Exception(10108));
    var self = this;
    if (this.pkAutoIncrement) {
        db.incr(I.Const.GLOBAL_KEY_PREFIX + this.abb, function(err, id) {
            if (err) return cb(new I.Exception(10104, err));
            self.addHash(object, cb, id);
        });
    } else {
        this.addHash(object, cb);
    }
};

Model.prototype.addHash = function(object, cb, id) {
    if (id !== undefined) {
        object.setPK(id);
        var key = id;
    } else {
        var key = object.getPK();
    }
    var toDB = object.toAdd();
    if (I.Util.getLength(toDB) === 0) {
        return cb(new I.Exception(10105));
    }

    db.hmset(this.abb + key, toDB, function(err, result) {
        if (err) return cb(new I.Exception(10111, err));
        object.resetUpdateList();
        cb(null, object);
    });
};
/* add stuff end */

/* del stuff start */
Model.prototype.del = function(object, cb) {
    cb = cb || function() {};
    switch (this.type) {
        case I.Const.OBJECT_TYPE_HASH:
            this.delHash(object, cb);
            break;
        case I.Const.OBJECT_TYPE_LIST:
            this.delList(object, cb);
            break;
        default:
            throw new I.Exception(10109);
    }
};

Model.prototype.delHash = function(object, cb) {
    var index = I.Util.isString(object) ? this.abb + object : this.abb + object.getPK();

    db.del(index, function(err, result) {
        if (err) return cb(new I.Exception(10110, err));
        cb(null, object);
    });
};

Model.prototype.delList = function(list, cb) {
    var self = this;
    var deledCount = 0;

    if (list.list.length === 0) {
        cb(null, list);
        return
    }

    var dbMulti = db.multi();
    // del list index
    dbMulti.del(this.abb + list.getPK());
    
    // del hash
    list.getKeys().forEach(function(v) {
        dbMulti.del(global[self.childModel].abb + v);
    });

    dbMulti.exec(function(err, results) {
        if (err) return cb(new I.Exception(10116, err));
        list.reset();
        cb(null, list);
    });
};
/* del stuff end */

/* update stuff start */
Model.prototype.update = function(object, cb) {
    cb = cb || function() {};
    switch (this.type) {
        case I.Const.OBJECT_TYPE_HASH:
            this.updateHash(object, cb);
            break;
        case I.Const.OBJECT_TYPE_LIST:
            this.updateList(object, cb);
            break;
        default:
            throw new I.Exception(10106);
    }
};

Model.prototype.updateHash = function(object, cb) {
    var toDB = object.toUpdate();
    // filter columns are not allowed to update
    this.updateFilter.forEach(function(v) {
        delete toDB[v];
    });
    // nothing to update
    if (I.Util.getLength(toDB) === 0) {
        cb(null, object);
        return;
    }
    db.hmset(this.abb + object.getPK(), toDB, function(err, result) {
        if (err) return cb(new I.Exception(10119, err));
        object.resetUpdateList();
        cb(null, object);
    });
};

Model.prototype.updateList = function(list, cb) {
    var self = this;
    var util = I.Util;
    var dbMulti = db.multi();

    var exec = function exec() {
        dbMulti.exec(function(err, results) {
            if (err) return cb(new I.Exception(10117, err));
            cb(null, list);
        });
    };

    // del
    list.toDelList.forEach(function(child) {
        var pk = child.getPK();
        dbMulti.del(global[self.childModel].abb + pk);
        dbMulti.hdel(self.abb + list.getPK(), pk);
        list.remove(pk);
    });
    list.toDelList = [];

    // update
    list.toUpdateList.forEach(function(child) {
        var toDB = child.toUpdate();
        global[self.childModel].updateFilter.forEach(function(v) {
            delete toDB[v];
        });
        if (util.getLength(toDB) === 0) return;
        dbMulti.hmset(global[self.childModel].abb + child.getPK(), toDB);
    });
    list.toUpdateList = [];

    // add
    var toAddListLength = list.toAddList.length;
    if (toAddListLength === 0) {
        exec();
        return;
    }

    var addedCount = 0;
    list.toAddList.forEach(function(v) {
        global[self.childModel].add(v, function(err, child) {
            list.insert(child);
            ++addedCount;
            dbMulti.hset(self.abb + list.getPK(), child.getPK(), 1);
            if (toAddListLength === addedCount) {
                list.toAddList = [];
                exec();
            }
        });
    });
};
/* update stuff end */

/* Interval Sync */
Model.prototype.updateSync = function(object) {
    switch (this.type) {
        case I.Const.OBJECT_TYPE_HASH:
            this.updateHashSync(object);
            break;
        case I.Const.OBJECT_TYPE_LIST:
            this.updateListSync(object);
            break;
        default:
            throw new I.Exception(10121);
    }
};

Model.prototype.updateHashSync = function(object) {
    var toDB = object.toUpdate();
    // filter columns are not allowed to update
    this.updateFilter.forEach(function(v) {
        delete toDB[v];
    });
    // nothing to update
    if (I.Util.getLength(toDB) === 0) return;

    db.hmset(this.abb + object.getPK(), toDB, function(err, result) {
        if (err) return console.log(new I.Exception(10122, err));
        object.resetUpdateList();
    });
};

Model.prototype.updateListSync = function(list) {
    var self = this;
    var util = I.Util;
    var dbMulti = db.multi();

    // del
    list.toDelSyncList.forEach(function(child) {
        var pk = child.getPK();
        dbMulti.del(global[self.childModel].abb + pk);
        dbMulti.hdel(self.abb + list.getPK(), pk);
    });
    list.toDelSyncList = [];

    // update
    list.toUpdateSyncList.forEach(function(index) {
        var child = list.get(index);
        var toDB = child.toUpdate();
        global[self.childModel].updateFilter.forEach(function(v) {
            delete toDB[v];
        });
        if (util.getLength(toDB) === 0) return;
        dbMulti.hmset(global[self.childModel].abb + child.getPK(), toDB);
    });
    list.toUpdateSyncList = [];

    // add
    list.toAddSyncList.forEach(function(index) {
        var child = list.get(index);
        var toDB = child.toAdd();
        dbMulti.hmset(self.abb + index, toDB);
    });
    list.toAddSyncList = [];

    dbMulti.exec(function(err, results) {
        if (err) console.log(new I.Exception(10123, err));
    });
};

exports.Model = Model;
